== MPLS Layer3 VPN Example

This version of the MPLS VPN example illustrates template-centric implementation
where the main logic is driven by the template, while the Java code performs
auxiliary computations. Functionality-wise it is the same as mpls-vpn example.

=== Example Overview

This example illustrates Layer3 VPNs in a service provider MPLS
network. This README file contains information related to the development of
the example and the l3vpn service.

=== Packages

.l3vpn
This package contains the datamodel and service mapping for the actual
l3vpn service.

.l3vpnui
This package contains the custom Web UI widget used for the example.

.NED Packages
In addition to the two packages above three different NED packages
will be copied to the example environment during the build process:
cisco-ios, cisco-iosxr and juniper-junos.

=== Service Mapping

The service mapping in this example is template-centric, but with some Java code
involved. The main task of the Java code is to perform IP address/mask
computations such as network prefix to network mask transformation or finding
next available IP address. The result of the computation is stored in the
operational data in the transaction and later picked up by the template. After
performing the necessary calculations the Java code invokes the template.

The configuration templates uses XPath to select from both the service
configuration data and auxiliary operational data created by the service.
The templates maps this input data to the data model representation of device
configuration for all device types in the network.

Service-Model ------ Java Logic
     |                   |
     |             Auxiliary data
     \            /
      \          /
       \        /
        Template
           |
    Vendor Device Model

==== Java Logic

The Java logic is found in the l3vpn package and the relevant
Java file is l3vpn/src/java/src/com/example/l3vpn/l3vpnRFS.java.

There is a number of 'config false' leafs in the l3vpn.yang data model. All of
them are the auxiliary data that is populated by the Java code. The approach
taken by this example was to populate the auxiliary data in the PRE_MODIFICATION
callback. This is primarily beneficial for the auxiliary data located in the
shared structures to make sure it does not get deleted when the service is
deleted. But it is as well applicable to the data inside the service instance
itself as it will be recomputed every time the service is touched or deleted if
the subtree this data belongs to is removed.

==== Template
There is only one template in the l3vpn package: l3vpn.xml. It contains the
main service logic. Yet because the service is implemented as a mix of Java and
template, the template needs to be invoked from the Java code.

No variables are passed to the template when it is invoked. Instead the template
reads all of its input from the transaction. However, for convenience the
template does use a number of variables which are set in the template itself.
